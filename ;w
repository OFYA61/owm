const std = @import("std");
const posix = std.posix;

const wl = @import("wayland").server.wl;
const wlr = @import("wlroots");
const xkb = @import("xkbcommon");

const gpa = std.heap.c_allocator;

const OwmServer = struct {
    wl_server: *wl.Server,
    socket: [:0]const u8,

    wlr_backend: *wlr.Backend,
    wlr_output_layout: *wlr.OutputLayout,
    wlr_scene: *wlr.Scene,
    wlr_scene_layout: *wlr.SceneOutputLayout,
    outputs: wl.list.Head(OwmOutput, .link) = undefined,
    new_output_listener: wl.Listener(*wlr.Output) = .init(newOutputCallback),

    wlr_renderer: *wlr.Renderer,
    wlr_allocator: *wlr.Allocator,

    fn init() anyerror!OwmServer {
        const wl_server = try wl.Server.create();
        var buf: [11]u8 = undefined;
        const socket = try wl_server.addSocketAuto(&buf);

        const wlr_backend = try wlr.Backend.autocreate(try wl.EventLoop.create(), null);
        const wlr_renderer = try wlr.Renderer.autocreate(wlr_backend);
        try wlr_renderer.initServer(wl_server);
        const wlr_allocator = try wlr.Allocator.autocreate(wlr_backend, wlr_renderer);

        _ = try wlr.Compositor.create(wl_server, 5, wlr_renderer); // Necessary for clients to allocate surfaces
        _ = try wlr.Subcompositor.create(wl_server); // Allows to assign the role of subsurfaces
        _ = try wlr.DataDeviceManager.create(wl_server); // Clipboard

        const wlr_output_layout = try wlr.OutputLayout.create(wl_server); // Utility for working with an arrangement of scren in a physical layout
        const wlr_scene = wlr.Scene.create();

        var server = OwmServer{
            .wl_server = wl_server,
            .socket = socket,
            .wlr_backend = wlr_backend,
            .wlr_renderer = wlr_renderer,
            .wlr_allocator = wlr_allocator,
            .wlr_output_layout = wlr_output_layout,
        };

        server.outputs.init();
        wlr_backend.events.new_output.add(&server.new_output_listener);

        return server;
    }

    fn deinit(self: *OwmServer) void {
        self.wlr_output_layout.destroy();
        self.wlr_allocator.destroy();
        self.wlr_renderer.destroy();
        self.wlr_backend.destroy();
        self.wl_server.destroy();
    }

    fn run(self: *OwmServer) anyerror!void {
        try self.wlr_backend.start();
        std.log.info("Running compositor on WAYLAND_DISPLAY={s}\n", .{self.socket});
        self.wl_server.run();
    }

    /// Called when a new display is discovered
    fn newOutputCallback(listener: *wl.Listener(*wlr.Output), new_output: *wlr.Output) void {
        const server: *OwmServer = @fieldParentPtr("new_output_listener", listener);
        if (!new_output.initRender(server.wlr_allocator, server.wlr_renderer)) {
            std.log.err("Failed to initialize render with allocator and renderer on new output\n", .{});
            return;
        }

        var state = wlr.Output.State.init();
        defer state.finish();
        state.setEnabled(true);
        if (new_output.preferredMode()) |mode| {
            std.log.info("Output has the preferred mode {}x{} {}Hz\n", .{ mode.width, mode.height, mode.refresh });
            state.setMode(mode);
        }
        if (!new_output.commitState(&state)) {
            return;
        }

        OwmOutput.create(server, new_output) catch {
            std.log.err("Failed to allocate new output", .{});
            new_output.destroy();
            return;
        };
    }
};

const OwmOutput = struct {
    owm_server: *OwmServer,
    wlr_output: *wlr.Output,
    link: wl.list.Link = undefined,

    frame_listener: wl.Listener(*wlr.Output) = .init(frameCallback),
    request_state_listener: wl.Listener(*wlr.Output.event.RequestState) = .init(requestStateCallback),
    destroy_listener: wl.Listener(*wlr.Output) = .init(destroyCallback),

    fn create(server: *OwmServer, wlr_output: *wlr.Output) anyerror!void {
        const owm_output = try gpa.create(OwmOutput);
        errdefer gpa.destroy(owm_output);

        owm_output.* = .{
            .owm_server = server,
            .wlr_output = wlr_output,
        };

        wlr_output.events.frame.add(&owm_output.frame_listener);
        wlr_output.events.request_state.add(&owm_output.request_state_listener);
        wlr_output.events.destroy.add(&owm_output.destroy_listener);

        server.outputs.append(owm_output);

        // Add the new display to the right of all the other displays
        const layout_output = server.wlr_output_layout.addAuto(wlr_output);
        const scene_output = server.wlr_scene.createSceneOutput(wlr_output); // Add a viewport for the output to the scene graph.
        server.wlr_scene_layout.addOutput(layout_output, scene_output); // Add the output to the scene output layout. When the layout output is repositioned, the scene output will be repositioned accordingly.
    }

    /// Called every time when an output is ready to display a farme, generally at the refresh rate
    fn frameCallback(listener: *wl.Listener(*wlr.Output), wlr_output: *wlr.Output) void {
        const output: *OwmOutput = @fieldParentPtr("frame_listener", listener);
        const scene_output = output.owm_server.wlr_scene.getSceneOutput(wlr_output).?;
        // Render the scene if needed and commit the output
        _ = scene_output.commit(null);

        var now = posix.clock_gettime(posix.CLOCK.MONOTONIC) catch @panic("CLOCK_MONOTONIC not supported");
        scene_output.sendFrameDone(&now);
    }

    /// Called when the backend requests a new state for the output. E.g. new mode request when resizing it in Wayland backend
    fn requestStateCallback(listener: *wl.Listener(*wlr.Output.event.RequestState), event: *wlr.Output.event.RequestState) void {
        const output: *OwmOutput = @fieldParentPtr("request_state_listener", listener);
        _ = output.wlr_output.commitState(event.state);
    }

    fn destroyCallback(listener: *wl.Listener(*wlr.Output), wlr_output: *wlr.Output) void {
        const output: *OwmOutput = @fieldParentPtr("destroy_listener", listener);

        output.frame_listener.link.remove();
        output.request_state_listener.link.remove();
        output.destroy_listener.link.remove();
        output.link.remove();

        gpa.destroy(output);
        wlr_output.destroy(); // TODO: figure out if this destory needs to get called or not
    }
};

const OmwToplevel = struct {};

const OwmPopup = struct {};

const OwmKeyboard = struct {};

pub fn main() anyerror!void {
    wlr.log.init(.debug, null);

    var owm_server = try OwmServer.init();
    defer owm_server.deinit();

    try owm_server.run();
}
